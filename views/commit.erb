$('commit_index').innerHTML = "<%= j @commit_index + 1 %>";
$('commit_message').innerHTML = "<%= j @commit.message %>";
$('committer_author_details').innerHTML = "<%= h @commit.committer.name_email %><%= (@commit.committer != @commit.author ? " for #{h @commit.author.name_email}": "") %>";
$('committer_date_time').innerHTML = "<%= j @commit.date.nice %>";
$('diff_message').innerHTML = "<%= j @diff_data[:message] %>";
queue = [];
<% if @diff_data[:type] == 'rename' %>
  queue.push(function()
  {
    Effect.ScrollTo($$("body")[0], { duration: <%= @delay %>, offset: 0, afterFinish: function()
    {
      if(queue.length > 0)(queue.shift())();
    } });
  });
<% end %>
<% if @diff_data[:content] %>
  <% @diff_data[:content].each do |change| %>
    <% if false && @diff_data[:type] == 'change' %>
    <% elsif change[:mode] == :add %>
      $("diff").setStyle({ 'paddingTop': $('header').getHeight() + "px" });
      queue.push(function()
      {
        //console.log("Starting an add...");
        var wrapper = new Element('div');
        wrapper.update("<%= j change[:lines] %>").hide();

        var scrollOffset = -(diffContentFontSize * 3) - $('header').getHeight();
        var insertPoint = $('diff_content').down(<%= change[:start] - 1 %>);
        var insertDuration = (scrollToDistance(insertPoint, scrollOffset) / (diffContentFontSize * <%= @lps_scroll %>));

        if((scrollToDistance(insertPoint, scrollOffset)) <= 0)
        {
          scrollOffset = 0;
          insertDuration = 0;
        }

        //console.log("issuing a scroll to for an add, to ", insertPoint.cumulativeOffset(), " offset by ", scrollOffset, "px taking ", insertDuration, "seconds, total page height", $$("body")[0].getHeight(), "px");

        Effect.ScrollTo(insertPoint, { duration: insertDuration, offset: scrollOffset, afterFinish: function()
        {
          insertPoint.insert({ 'after': wrapper });

          var blindDuration = (blindDistance(wrapper) / (diffContentFontSize * <%= @lps_change %>));
          //console.log("issuing a blind down for a add, taking ", blindDuration, " seconds");
          wrapper.blindDown({ duration: blindDuration, afterFinish: function()
          {
            wrapper.replace(wrapper.innerHTML);
            setTimeout(function()
            {
              if(queue.length > 0) (queue.shift())(); 
            }, <%= 3 * (1000 / @lps_change.to_f) %>);
          } });

          if(blindDistance(wrapper) > document.viewport.getHeight())
          {
            //console.log("issuing a scroll to bottom for an add, taking ", [blindDuration - 0.5, 0].max(), " seconds, with a delay of ", (blindDistance(wrapper) - 0.5 < 0 ? 0 : 0.5), " seconds");
            Effect.ScrollToBottom(wrapper, { duration: [blindDuration - 0.5, 0].max(), delay: (blindDistance(wrapper) - 0.5 < 0 ? 0 : 0.5) });
          }
        } });
      });
    <% elsif change[:mode] == :remove %>
      $("diff").setStyle({ 'paddingTop': $('header').getHeight() + "px" });
      queue.push(function()
      {
        //console.log("Starting a remove...");
        var removePoint = new Element('div');
        $('diff_content').down(<%= change[:start] %>).insert({ 'before': removePoint });

        <% change[:times].times do %>
          removePoint.insert({ 'bottom': $('diff_content').immediateDescendants()[<%= change[:start] + 1 %>] });
        <% end %>

        var scrollOffset = -(diffContentFontSize * 3) - $('header').getHeight();
        if(removePoint.cumulativeOffset()[1] + scrollOffset < 0) scrollOffset = -(removePoint.cumulativeOffset()[1]);
        var scrollDuration = (scrollToDistance(removePoint, scrollOffset) / (diffContentFontSize * <%= @lps_scroll %>));
        //console.log("issuing a scroll to for a remove, to ", removePoint.cumulativeOffset(), " offset by ", scrollOffset, "px taking ", scrollDuration, "seconds, total page height", $$("body")[0].getHeight(), "px");        
        Effect.ScrollTo/*Bottom*/(removePoint, { duration: scrollDuration, offset: scrollOffset, afterFinish: function()
        {
          var blindDuration = (blindDistance(removePoint) / (diffContentFontSize * <%= @lps_change %>));
          //console.log("issuing a blind up for a remove, taking ", blindDuration, " seconds");
          removePoint.blindUp({ duration: blindDuration, afterFinish: function()
          {
            removePoint.remove();
            if(queue.length > 0) (queue.shift())(); 
          } });

/*
          if(blindDistance(removePoint) > document.viewport.getHeight())
          {
            Effect.ScrollTo(removePoint, { duration: [blindDuration - 0.5, 0].max(), delay: (blindDuration - 0.5 < 0 ? 0 : 0.5) });
          }*/
        } });
      });
    <% end %>
  <% end %>
<% end %>

<% if @commit_index < @commits.length - 1 %>
  queue.push(function()
  {
    new Ajax.Request("/commit/<%= @commit_index.to_i + 1 %>", { method: 'get' });
  });
<% end %>

if(queue.length > 0) (queue.shift())();